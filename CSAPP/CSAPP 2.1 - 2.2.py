# 2-1 정보의 저장
# 컴퓨터는 0과 1인 2진수로 수를 해석하고 메모리에 주소지정이 가능한 8bit단위의 1byte라는 블록을 사용합니다.
# 컴퓨터는 메모리를 가상메모리라고하는 거대한 바이트의 배열로 취급하고 거기에 접근하는 각 주소의 모음을 가상 주소공간이라고 표현합니다.
# 왜 자꾸 가상이라고 하냐면 실제로는 떨어져 있을 수도 있겠지만, 접근을 하는데 있어서는 전혀 제약사항이 없기 때문에
# 그 메모리 공간을 적절한 크기로 할당해서 프로그램 데이터, 인스트럭션, 제어정보등을 저장하고 주소를 할당합니다.

# 2-1.1 16진수 표시

# 1byte는 8비트입니다. 따라서 2진수로 00000000(2)로 표기할 수 있습니다.
# 8비트로 표기 할 수 있는 수를 10진수로 나타내면 0부터 255까지입니다.
# 이 2진수를 보기 쉽게하기 위해 16진수를 사용합니다. 따라 서 각 자리수가 0~15까지를 나타낼 수 있고 A:10, B:11, C:12, D:13, E:14, F:15 로 매칭합니다.
# 컴퓨터는 10진,2진 16진수를 수동으로 변환합니다.

# 10진수 -> 2진수 변환  2의 제곱수의 합으로 표시 0b11011010(2) -> 218 -> 0xDA
# 2진수 -> 10진수 변환  위 방식의 역순
# 2진수 -> 16진수 변환  4단위씩 끊어서 변환
# 16진수 -> 2진수 변환  한자리별로 4단위를 생성하여 결합

# 2.1.2 데이터의 크기

# 모든 컴퓨터는 워드 크기를 규격으로 가지게 되었는데 주소값의 정규크기는 워드크기를 따라갑니다.
# C언어는 정수와 부동소수점 데이터를 위한 여러가지 데이터 포맷을 지원하는데 각 타입별로 데이터 크기는 외워야 한다고 생각합니다.

# char, unsigned char        1byte
# short, unsigned short      2byte
# int, unsigned              4byte
# long unsigned long         4byte(32bit) 8byte(64bit)
# int32_t, uint32_t          4byte
# int64_t, uint64_t          8byte
# char *                     4byte(32bit) 8byte(64bit) # 주소값이라서
# float                      4byte
# double                     8byte
# 그냥은 부호형, unsigned가 붙으면 비부호형(양수만)

# 2.1.3 주소지정과 바이트 순서

# little endian과 big endian에 대해서
# 두 방법은 바이트르 정렬하는 두가지 방법임
# ex) 어떤 데이터의 바이트 배열이 0x12345678 이라고하면
# little endian 방식: 78 56 34 12
# big endian 방식: 12 34 56 78 
# 두개씩 끊는 이유는 16진수 문자 하나당 4bit이고 8bit가 되어야 1byte이기 때문

# little endian 방식이 왜 도입되었느냐,
# 첫번째, CPU의 연산 접근 특성상 하위비트부터 접근하는 것이 용이하고 이를 돕기 위해
# 두번째, 더 작은 크기의 타입으로 변환 시 빠르게 절삭(변환) 할 수 있기 때문에 효율적
# 세번째, CPU 설계 초창기에 연산과 메모리접근을 단순화하려고 리틀엔디안 방식을 고안했고 그것이 지금까지 쭉 이어져 옴(그냥 전통)

# 이 바이트 배열의 차이는 일상생활에는 크게 지장이 없지만 신경써야 할 이슈가 세가지 있음
# 첫째, 네트워크를 통해 데이터를 전송할때,
#  ex)0x11112222를 보내고 그 다음 0x33334444을 보내서 합쳐야하는데 받는 쪽은 0x22221111, 0x44443333이 와버려서
# 합치면 0x2222111144443333이 되어버림. 데이터 손실

# 두번째는 데이터를 살펴볼 때
# 나중에 어셈블리어로 데이터나 인스트럭션 바이트 배열을 까봐야 할 때
# 아맞다 얘 리틀 엔디안이었지 라고 생각을 해야합니다.

# 셋째는 캐스트나 유니온을 통해 타입변환을 할때
# 예를 들어 int에서 float이나 pointer로 변환을 하게 되면,
# 비트를 읽는 해석 자체가 완전 바뀌게 되어서 리틀 엔디안 방식임을 감안하지 않으면 다른 결과가 나올 수 있음

# 2.1.4 스트링의 표시
# 스트링은 문자열을 으미하고 항상 널문자('\0')를 마지막에 넣습니다. 그리고 각 문자는 ASCII문자로 인코딩 됩니다.
# "12345" -> 31 32 33 34 35 00

# 2.1.5 코드의 표현
# 컴퓨터의 프로그램은 연속의 인스트럭션으로 표현할 수 있는데, 인스트럭션을 인코딩한 결과는 컴퓨터에 따라 제각각입니다.
# 그리고 그 결과를 까보면 내가 1을 더했는지 for문을 썼는지 이런건 컴퓨터 입장에서 전혀 알 턱이 없습니다. 0과 1밖에 없으니까요

# 2.1.6 부울 대수
# 부울 대수는 {0,1}로 정의되는 수입니다. 그냥 0 또는 1인 수인거죠
# 이 부울 대수에는 연산자가 4가지 있는데 |(or) &(and) ^(xor) ~(not)이 있습니다.
# |는 둘 중 하나라도 1이면 1, &는 둘 중 하나라도 0이면 0, ^는 두개가 다를때만 1, ~은 0이면 1, 1이면 0으로 바꾸는 연산자입니다.
# ^(xor)는 본인의 값을 가진 채로 암호화 할때 많이 씁니다.

# 2.1.7 C에서의 비트수준 연산
# 여러가지 비트의 연속인 비트 벡터가 있다고 했을 때 그 비트 벡터끼리의 연산을 C에서 지원해줍니다.

# 2.1.8 C에서의 논리연산
# 논리연산은 위의 비트연산과 다르게 그저 참, 거짓 둘 중 하나밖에 안나옵니다.
# 따라서 연산자도 살짝 다릅니다 ||(or) &&(and) !(not)

# 2.1.9 C에서의 쉬프트 연산
# 어려운거 없고 >> 면 오른쪽으로 비트 이동, << 왼쪽으로 비트이동
# 다만 >>할때 논리 우측 쉬프트, 산술 우측 쉬프트가 있는데, 논리 우측 쉬프트는 빈자리를 0으로 채우는것,
# 산술 우측 쉬프트는 MSB라고하는 최상위 비트 값으로 채웁니다.
# 보통 부호형 연산할때 값 보존을 위해서 산술 우측 쉬프트를 사용합니다.

# 2.2 정수의 표시

# 2.2.1 정수형 데이터 타입
# C에서 지원하는 정수형 데이터 타입은 비부호형, 부호형 말고도 char, short, long도 있습니다.

# 2.2.2 비부호형 인코딩


# 2.2.3 2의 보수 인코딩
# 2의 보수란?, 1의보수, 부호-크기 방식에 대한 소개

#2.2.4 비부호형과 부호형 간의 전환
# 비트배열은 그대로, 하지만 비트 해석방식의 차이

# 2.2.5 C에서 부호형과 비부호형의 비교
# Casting 시 명시적, 묵시적 캐스팅의 차이와 주의해야할 점
# (비부호형과 부호형을 연산하게 되면 묵시적으로 비부호형끼리의 연산으로 바뀜) 일례로 -1 > 0U
# 그리고 printf 에서 %d, %x, %f, %u에 따라 출력 방식을 따름

# 2.2.6 수의 비트 표시를 확장하기
# 비부호형은 그냥 0을 넣으면 됨
# 부호형은 수 유지를 위해 MSB를 붙임 예시도 같이 [1100]
# 길이 확장과 부호형 비부호형의 변환을 같이 하게 되면? uy=sx

#2.2.7 수의 절삭
# 수를 절삭하는 표현과 mod표현
# 간단하게 절삭만하고 다시 비부호형, 부호형에 맞게 읽으면 됨.

# 2.2.8 Signed와 Unsigned의 조언
# 비부호형과 부호형의 묵시적인(또는 원치않은) 타입변환은 가끔 직관적인 결과를 내놓기 않기 때문에 최대한 쓰지 않는 것이 좋음
# 예를 들어 length-1 이라는 구문에서 length가 0U 일경우 UMax를 뱉는다
# 그래서 보통 비부호형은 쓰지 않고 왠만하면 모든 경우를 다 부호형으로 사용하는 것이 안전함.
