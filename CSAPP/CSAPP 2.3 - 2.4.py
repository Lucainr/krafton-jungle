# 2.3 정수의 산술연산
# 이번 장은 비부호형, 2의 보수형의 덧셈과 곱셈
# 그리고 표기할수 있는 유한한 범위로 인해 생기는 오버플로우와 그 값에 대해서 알아보는 장입니다.

# 2.3.1 비부호형 덧셈
# 예를 들어서 우리가 숫자를 4비트로만 표현할 수 있다고 치면 비부호형이니까 표현할 수 있는 수가 0~15까지 입니다.

# 여기에서 우리가 6이랑 12를 더했어요 그러면 18이죠? 근데 15까지밖에 표현 못해요. 그러면 오버플로우가 발생합니다.
# 오버플로우 값 구하는건 어렵지 않습니다. 그냥 받아올림했는데 그 값이 없어진거에요
# 비트로 보여드리겠습니다. [0110]과[1100]을 더하면 [10010]이죠? 근데 4비트밖에 표현을 못해서 4비트까지 절삭합니다. mod 2^4로도 나타냄
# 그러면 [0010]이죠? 그래서 6과 12를 더한 답은 2가됩니다.(정수표현을 4비트로 할당한 경우)

# |----|--------------------------------| ----- |
# 0    2                              16(0)      18

# 오버플로우가 발생하면 반대쪽으로 텔레포트해서 다시 출발한 느낌

# 수식이 나오는데 x+y가 2^w보다 작을 때는 그냥 x+y인데, x+y가 2^w이상이면 2^w를 뺀 값이 결과값이다.

# 여기서 한가지 법칙이 나오는데 비부호형 데이터 x and y를 더한 값 s가 x or y보다 작으면 무조건 오버플로우가 발생했다.

# 비부호형 데이터의 역원에 대해서
# 역원이란 특정 수 x에 대해서 y를 더하면 0이 되는 y를 말하고 지금 우리가 하는 정수 덧셈의 세계관에선 역원이 존재한다.
# 아니 근데 양수 두개 더했는데 어떻게 0이되냐? 당연히 오버플로우 말하는거입니다.
# 2^w를 딱 맞추면 0이 되기 때문에 x에 대한 역원 -x는 2^w-x입니다.

# 예시 위에 4비트로만 표현된 세계관에서 6에 대한 역원은 16-6=10 입니다.

# 2.3.2 2의 보수의 덧셈

# 부호가 있는 수의 덧셈입니다. 언제 오버플로우가 발생할까요?
# 큰 양수 두개를 더하면 +쪽으로 발생할거고(positive overflow)
# 엄청 작은 양수(절대값이 큰 음수) 두개를 더하면 -쪽으로도 발생하겠죠(negative overflow)

# 어떻게 하느냐? 똑같습니다. 두 수를 비트 더하기 한 다음에 표현할 수 있는 크기만큼 절삭하면 끝
# 예시) x=[10100] , y=[10001] = 00101
# 예시2) x=[10111] , y=[01000] = 11111

# 2의 보수의 덧셈 세계관에서의 역원?

# 부호가 있으니까 x와 더해서 0이 되는건 -x입니다.
# 3에 대한 역원 -3, 14에 대한 역원 -14 당연한 소리
# 그런데 한 가지 주의해야할 점. TMin(2의보수형태로 표기한 수 중 표현할 수 있는 젤 작은 수) [1000---]
# TMin의 역원은 자기 자신입니다. [1000---] + [1000---] = [0000---] (절삭되니까)

# 2.3.4 비부호형 곱셈

# 곱셈이라고 다를거 없습니다. 생각해보면 덧셈만 가지고도 오버플로우가 그렇게 나는데 곱셈은 대충 곱해도 나오겠다..
# 비트로 곱하는 방법도 사실 있긴한데 10진수랑 똑같습니다.
#          0110 <- 6(10)
#          0101 <- 5(10)
# -----------------------
#          0110
#         0000  <-1번째 비트가 0이니까
#        0110
#       0000 <- 3번째 비트가 0이니까
# ------------------------
#         11110 <- 30(10)
# 솔직히 그냥 10진수로 변환하고 곱하는게 편할겁니다.

# 그런데 이제 우리가 정수를 4비트로만 표현할 수 있다면 위의 예시로 쳤을때 [1110](14)가 나오는거죠
# 똑같이 표현할 수 있는 w비트에 대해서 w비트만 남기고 절삭한겁니다. 이를 다르게 표현하면은 mod 2^w 모듈러 연산했다고 하죠

# 정리: 곱하고나서 w비트만 남기고 절삭해라 = 곱한값을 2^w 모듈러 연산해라

# 2.3.5 2의 보수 곱셈
# 비부호형이랑 똑같습니다.
# 곱한 값에 w비트만 남기고
# 그런데 이제 2의 보수 같은 경우에는 MSB 때문에 결과값이 살짝 다르겠죠
# 그냥 계산하고나서 절삭하고 2의보수로 수를 읽으시면 됩니다.
# 위의 예시로 들면 [0110]*[0101]=[1110]
#                  6(10)  5(10) -2(10)   
# 법칙중에 비트 기준, 비부호형이랑 부호형의 곱셈연산의 결과 비트배열이 똑같다.

# ex) 정수표현이 3비트만 가능하다고 했을 때, 
# x=[100], y=[101] x*y=[010100] mod 2^3 = [100] mod 2^3
# unsigned는 [100]을 4라고 읽고 2의 보수(부호형)은 -4라고 읽겠죠
# 결과 비트는 똑같은데 수를 해석하는 방식이 달라서 결과값이 다르게 느껴지는 것

# 2.3.6 상수를 이용한 곱셈
# x*14 뭐 이런거 할 때 다른 표현 방식을 소개하는 장입니다.
# 상수곱셈을 시프트 연산의 덧셈과 뺄셈으로 표현 할 수 있습니다.

# 우선 시프트 연산이 수와 무슨 연관이 있는 지부터 알아봅시다.
# x*2^k 일때 0<=k<w 인 k에 대해서 (x<<k) 로 표현할 수 있습니다.
# 반대로 k<0일때 (x>>|k|)로도 표현 할 수있습니다.
# 비트 수준으로 소개 x= [000100] x>>2 or x<<3

# 그럼 x*14를 시프트 연산으로 어떻게 표현하는지
# 14=2^3+2^2+2^1 이므로
# x*(8+4+2)=x*8+x*4+x*2=(x<<3)+(x<<2)+(x<<1) 쉬프트 3번 더하기 2번 = 총 연산 5번

# 또다른 방법
# 14=16-2=2^4-2^1
# x*(16-2)=x*2^4-x*2^1=(x<<4)-(x<<1) 쉬프트 2번 빼기 1번 = 총 연산 3번

# 2.3.7 2의 제곱으로 나눗셈하기
# 이게 좀 복잡합니다.
# 이게 정수에 해당하는 문제라서 소숫점 아래 자리들에 대한 처리가 필요합니다. 
# 쉽게 말하면 정수는 소숫점 뒤? 아몰랑 걍 다 떼~

# 그렇담 양수의 소수에 대해서는 버림을 합니다. 예를 들어 (int) 3.9= 3
# 그런데 음수에서 문제가 발생하는데, (int) -3.2=-3  숫자가 커졌네? -3.2<-3
# 이렇게 양수일땐 반내림, 음수일땐 반올림을 하게됩니다. 저희가 흔히 아는 0.5기준으로 1 더하고 빼는 그 반올림이 아닙니다.
# 여기서는 반내림=버림, 반올림=올림 입니다.
# 근데 비트 기준으로 봤을 때 내림하는게 훨~~씬 편합니다. 그냥 뒷부분 절삭해서 없애버리면 그만이거든요
# 그래서 음수 값에 대해서는 보정값인 Bias(바이어스)를 더해주게 됩니다.

# 왜 더하냐? 음수 양수 상관없이 다 반내림 해주고 싶어서, 연산을 통일화 해주고 싶어서
# 얼만큼 더하냐? 나누고 싶은 수 밑으로 수가 하나라도 존재한다면 1을 더해주고 싶다.
# ex) -12340=[1100/1111/1100/1100] 여기서 나 2^8로 나누고 싶다.
# 그러면 오른쪽부터 8비트(1100/1100)는 나눴을 때 나머지가 되고 남은 왼쪽 부분(1100/1111)이 몫이 된다. <-이걸 이해하셔야 합니다.
# 그냥 절삭하면 [ 1111 / 1111 / 1100 / 1111 ]이 되니까 뒤에 [1100/1100]은 나머지 소숫점 아랫 자리가 되어 사라지는 거고
#              (1로 채운 부분) (시프트 하기 전 왼쪽 부분)
# 근데 사라지는 부분에 1이 단 하나라도 있으면(소숫점 자리가 있다) 몫에 1을 더해주고 싶다. 라는 뜻으로
# (-3.x 라면 -3이 되어야 하니까 일단 -2.x로 만듦)
# bias(보정) 값은 없어지는 비트가 k라 치면 2^k -1이 됩니다.
# [1111/1111]을 더해줘야 하나라도 1이 있을 때 받아올림이 되서 몫 부분에 1이 더해지지
# 그래서 2^8로 나누고 싶으면 bias를 [1111/1111]=2^8-1로 설정해서 더해준 다음
# 산술 우측 시프팅으로 8칸 옮겨주면 끝

# bias 더한다. 왜? 소숫점아래 수가 있을 경우 1 더하고 내림하려고
# 얼마나 더하냐? 절삭할 비트수가 k라면 2^k -1 = (1<<k)-1 로도 표현 가능
# 더한 다음 x>>k 우측 시프팅 ( 음수니까 좌측엔 1로 도배 해주셔야 합니다.) = x를 2^w로 나눈다는 뜻

# 따라서 식 하나로 표시 할 수 있습니다
# (x<0 ? x+(1<<k)-1 : x ) >> k    => x<0이면 (x+(1<<k)-1)>>k, x>=0이면 (x>>k)
#  조건     참일 때   거짓일때

# 2.3.8 정수 산술연산에 대한 마지막 고찰
# 컴퓨터는 유한한 길이의 워드를 사용하기 때문에 정수의 산술연산은 지원하는 수 크기를 초과할 수 있습니다. 이를 오버플로우라고함
# 이에 컴퓨터는 모듈러 연산이라는 형태로 오버플로우의 값을 표시합니다.
# 사실 덧셈, 뺄셈, 곱셈 ,나눗셈은 unsigned 이건 signed이건 크게 다를 바가 없습니다. 그냥 값구하고 절삭
# unsigned 자료형은 항상 연산할때 signed와 같이 연산하지 않도록 조심 또 조심!


# 2.4 부동소수점
# 부동소수점은 비트를 해석하는 방식이 정수와 아예 완전 다릅니다
# 지금까지의 비트 해석방식은 잊어라
# 일단 부동소수점이 왜 부동소수점이냐면 여기서 부가 뜰 부입니다 튜브가 물에 뜨는것처럼
# 그래서 float이구요 그래서 떠다니며 움직이는 소수점(자유롭게 움직이는 소수점)이라서 부동소수점입니다.
# 0.1 왼쪽으로 2칸 -> 0.001 오른쪽으로 4칸-> 10

# 우선 부동소수점은 수를 각각 V=x*2^y 의 형태로 나타냅니다.
# 한가지 알아 두어야 할 것은 부동소수점의 형태는 모든 수를 다 정확하게 표시하지 못합니다.
# 처음에 사용할때에도 정밀도 보다는 속도나 구현의 편의성을 두다보니 오차값이 발생할 수 있습니다.

# 지금까지 표준으로 사용하고 있는 부동소수점은 IEEE 표준 754방식입니다. 배워야 하는 친구 이름정돈 외워줘야겠죠?

# 2.4.1 비율이진수
# 쉽게 말하면 수를 2^i의 합산으로 표시 한다는겁니다.
# 먼저 설명할건 이진소수에 대한건데
# 우리가 흔히쓰는 10진수의 소수를 생각해보세요 12.34라면 10^1 * 1 + 10^0 * 2 + 10^-1 * 3 + 10^-2 * 4 로 표시하죠?
# 마찬가지로 2진수의 소수는 예를 들어 [10.111]이라면 2^2 + 2^-1 + 2^-2 + 2^-3 으로 표시합니다.

# 예시 : 5/16 = 4/16 + 1/16 = 1/4 + 1/16 = 2^-2 + 2^-4 =[0.0101]=0.3125
# 예시2 : 43/16 = 32/16 + 11/16 = 2 + 8/16 + 2/16 + 1/16 = 2 + 2^-1 + 2^-3 + 2^-4 = [10.1011]=2.6875

# 2.4.2 IEEE 부동소수점 표시
# 메인디쉬입니다.
# IEEE 표준은 수를 V=(-1)^s * M * 2^E 의 형태로 나타냅니다.
# 설명을 하자면 일단 최좌측 1비트는 그냥 0이면 양수, 1이면 음수 딱 이거밖에 안합니다. 2의 보수처럼 복잡한거 아닙니다.
# 그다음 예시와 함께 설명드리겠습니다.
# 0.0001100110011001 (2) = 1.100110011001 * 2^-4 로 표현할 수 있죠? 소숫점을 오른쪽으로 4칸 옮겨서 1.xx 형태로 만들었습니다.
# 이런식으로 1.xx으로 만드는걸 목표로 합니다. 수를 비트 표현 했을 때 가장 왼쪽의 1이 앞으로 오도록
# 그런 다음 소숫점을 옮긴 만큼 2^E로 나타냅니다. 이 때 E는 -4겠네요

# IEEE 표준 754에서 나름대로 규격을 정했는데,
# 먼저 맨 앞에 부호를 담당하는 비트를 s, M의 값을 담당하는 비트를 n, E를 담당하는 비트를 e라고 하겠습니다.
# float 32비트에서는 s=1비트, e는 8비트, n은 23비트로 할당했구요
# double은 s=1비트, e=11비트, n=52비트로 할당했습니다.

# 각각의 비트를 어떻게 구하는지 알아봅시다.

# E 혹은 e에 대해서 알아봅시다. 지수필드 라고합니다.
# E는 원래 수에서 구할 수 있는 2의 지수를 그대로 나타낸 것입니다. 위의 예시에선 -4였구요

# IEEE 표준에서는 세가지의 케이스로 비트를 해석하는데 그 기준이 지수필드입니다.
# 지수필드가 전부 0일때, 전부 1일때, 그 나머지 이렇게 나타냅니다.

# 먼저 지수필드가 전부 0도, 전부 1도 아닐때를 알아보겠습니다. 이를 정규화(Normalized) 값이라고 합니다 

# 먼저 알아야 할 것은 정렬과 비교가 수월하게 이루어지도록 지수필드를 unsigned로 표기하기로 했습니다.
# unsigned가 되버리면 좌측부터 1이 먼저나오면 큰수니까 signed면 2의 보수 표기 때문에 조건이 많아요

# 멀리 오긴했는데, 지수필드를 unsigned로 표기하려고 했고,
# 전부 0인 0과 전부 1인 255를 제외한 나머지 1~254의 범위가 E가 있을 수 있는 범위입니다.
# 따라서 원래라면 -128~127의 값을 가질 수 있는 E에 127을 더해줘서 1~254의 값을 가질 수 있게 해줍니다. (-1이랑 0은 버리구요)
# 그래서 127이 bias이고 1~254를 표현하는 지수필드를 e라고 합니다.

# 어떻게 접근하면 좋냐면 아까 소개한 수로 예를 들면 0.0001100110011001 (2) => 1.100110011001 * 2^(-4) 이고
# -4가 E 입니다. e= E+127 = 123 이고 [01111011] 이다.
# 위 수를 float의 비트배열로 표현할때 e가 쓰입니다.

# 그다음 M에 대해서 알아보겠습니다. 가수 필드라고 합니다.
# 1.xx로 나타내었을 때 xx~ 부분을 그대로 갖다가 박은 겁니다. 1.xx를 M, xx~ 부분을 보통 f라고 부릅니다.
# 여기서 알아야할 개념은 앞에 0.xx인 경우는 생각안하고 무조건 1.xx이라고 생각한거라 비트 하나를 아끼게 된겁니다.
# 아무튼 당연하겠지만 M=1+f의 관계가 성립합니다.

# 그래서 결국 소수를 비트배열로 인코딩하게되면 결과가
# s(1)eeeeeeee(8)fffffffffffffffffffffff(23)으로 나타나게 됩니다.
# 위 수로 예를 들자면 0/01111011/10011001100100000000000 = 0x3DCCC800로 표시할 수 있는거죠

# 두번째 케이스 e가 전부 0일때 이를 비정규화(denormalized) 값이라고 표현합니다.(e=0)
# 이때는 특수하게 1.xx * 2^-127 이 아니라 0.xx * 2^-126 이라고 생각하고 계산하는겁니다. 
# 왜 그러냐? 표현할 수 있는 범위를 더 촘촘하게 하기 위함인데, 전자를 택하게 되면 가장작은 값이 f가[00--001]일때 2^-127+2^-150 이 되고 
# 후자를 택하게 되면 마찬가지로 f가[00--001]일때 최솟값인데 2^-149가 최솟값이 됩니다.
# 따라서 더 작은 수까지 표현할 수 있기 때문에 후자를 택하는 겁니다. 전부 0이면 0인데 0과의 간격을 최대한 좁히기 위해

# 한가지 수정을 하자면 부동소수점은 +0.0, -0.0의 표현이 모두 있습니다. 하지만 이것은 의도 된 것이며 소수 그 수가 무한정이기 때문에
# -에서 0으로 수렴하는 것을 -0.0, +에서 0으로 수렴하는 것을 +0.0으로 유용하게 사용하고 있습니다.
# 1의 보수와 부호-크기 방식을 사용하지 않았던 것은, 단순히 0의 표현이 두가지 있는 것도 문제이지만,
# 덧셈과 뺄셈 등 산술로직이 너무 복잡하기 때문에 사용하지 않는 것입니다. (전가산기 구현 이런거 생각하시면됨, xor,and,or게이트로 구성)

# 세번째 케이스 e가 모두 1일때 이를 특수 값이라고 표현합니다. (e=255)
# f가 전부 0 이면 소숫점을 127칸 왼쪽으로 옮겼는데도 1이 하나도 보이지 않는다는 뜻으로 수가 너무 크다 (=infinity)
# f가 0이 아니라면 NaN으로 나타내는데 이때 각 비트는 수로써의 비트가 아니라 에러 출처나 다른 데이터들을 담아서 표현한다.
# NaN은 루트(-1)이나 무한대-무한대를 계산할때 리턴된다.

# 2.4.3 숫자 예제

# 앞서 설명했듯 지수필드와 가수필드의 비율은 정해진게 아닙니다. 지수필드가 늘어나면 표현할 수 있는 수의 범위가 늘어나고
# 가수필드가 늘어나면 수의 정밀도가 높아집니다.
# IEEE가 이를 고려해서 적당한 비율로 규격을 정한 것이 우리가 쓰는 float, double에서의 비율입니다.

# 예시로써 e=4bit, f=3bit로 가정하고 보겠습니다.

# 표현               비트배열          지수 필드(e,E,2^E)      가수 필드(f,M)       값(2^E*M, V, 10진수)
# 0                0 0000 000          0, -6, 1/64            0/8, 0/8           0/512,    0,   0.0
# 비정규화 값(최소값) 0 0000 001          0, -6, 1/64            1/8, 1/8          1/512, 1/512,  0.001953
# 비정규화 값(최대값) 0 0000 111          0, -6, 1/64            7/8, 7/8          7/512, 7/512,  0.013672
# 정규화 값(최소값)  0 0001 000           1, -6, 1/64            0, 8/8            8/512,  1/64,  0.015625
# 정규화 값(1)      0 0111 000           7,  0,  1              0/8, 8/8            8/8,     1,  1.0  
# 정규화 값(최댓값)  0 1110 111           14, 7, 128             7/8, 15/8         1920/8,  240,  240.0
# 무한대            0 1111 000               -                      -                       -

# 비정규화 값에는 e부분이 0이고 가수필드 f=M이다.
# 정규화 값에는 e부분이 모두 1도 아니고 0도 아니다. 한가지 주목할점은 1의 시작이 0111(bias)값과 동일해서 E=0이 된다. f는 전부 0
# 정규화에는 M=1+f
# 무한대는 지수, 가수에 대한 생각을 전혀 안하고 그냥 넘깁니다. 그냥 값에 무한대 넣어놓고 보냅니다.

# 정수와 부동소수점의 변환
# 정수 00000000000000000011000000111001을 변환해봅시다.
# 1.xx로 만들기 위해서는 왼쪽으로 13칸 이동해야하기 때문에, E=13이고 e는 140이 됩니다. e=[10001100]
# 그리고 f는 맨 왼쪽 1을 제외한 나머지 부분입니다. f=[100000011100100000000000000]
# 위 정수는 양수니까 s=0
# 합치면 0 / 10001100 / 100000011100100000000000000 로 변환됨. f 부분이 정수랑 그대로 겹침을 알 수 있음.

# 2.4.4 근사법
# 부동소수점 산술연산은 제한된 비트 내에서 이루어지기 때문에 범위와 정밀도가 한정됩니다. 그래서 근사값을 사용할 수 밖에 없음
# 근사하는 방법은 총 네가지가 있는데, 짝수근사법, 0방향근사법, 상향근사법, 하향근사법
# 짝수 근사법은 부호에 상관없이 (중요!)중간 값일 때 근사하려는 값이 짝수가 되도록 근사하는 방법 (0이면 그대로, 1이면 1더해서 0으로 만듦)
# 0방향 근사법은 일종의 버림이라고 생각하면 편합니다. 그냥 소숫점 때버리기 ex) 1.6->1 / -1.5->-1
# 하향 근사법은 무조건 버림. 숫자가 작아지는 쪽으로 ex) 1.6->1 / -1.5->-2
# 상향 근사법은 무조건 올림. 숫자가 커지는 쪽으로 ex) 1.3->2 / -1.5->-1

# 우리가 흔히 아는 0.4는 죽이고 0.5는 올리는 그 방식이 짝수 근사법과 매우 유사합니다.근데 이제 조금 다른점이 있다면,
# 예를들어 1.23500 이랑 1.24500이 있습니다. 10진수인데, 소수 둘째자리수까지 나타내라고 하면 우리는 보통 각각 1.24, 1.25로 나타내는데
# 짝수 근사법은 소수 둘째자리 수가 짝수가 되도록 만드는겁니다. 1.235->1.24, 1.245->1.24
# 다시 한번 강조하지만 중간 값일때만 적용합니다. 중간 값보다 작으면 버리고, 크면 올립니다.
# 2진수인 비트를 기준으로 봅시다. 근사하려는 비트 아래로 100이면 중간값이라고 생각합니다. 이때 보는 세 비트를 GRS(Guard, round, sticky)라고 합니다.
# 근사하려는 비트가 1이면 [1100]의 식으로 나타날 때 +1, [0100]으로 나타나면 그냥 버림

# 2.4.5 부동소수점 연산
# 이 교재에서는 덧셈과 곱셈의 방법을 가르쳐 주고 있진 않다.
# 부동소수점 역시 아벨그룹을 형성한다.

# 부동소수점의 곱셈
# 따라서 x+y=y+x가 성립하는 교환법칙이 성립함

# 하지만 연산 순서가 바뀌는 결합법칙은 성립하지 않는다. (a+b)+c!=a+(b+c)
# 왜냐하면 3.14+1e10-1e10 이라고 할때 (1e10은 10^10)
# (3.14+1e10)-1e10 = 1e10-1e10 = 0이 나온다.(너무 큰수와 연산해서 근사 되어버림) 반대로 3.14+(1e10-1e10)=3.14

# 부동소수점은 부호 비트가 표현되어 있기 때문에 소수 x에 대해 -x가 존재하고 이는 역원이 존재함을 알 수 있다.
# 덧셈에 대해서 무한대와 NaN은 역원이 존재하지 않습니다.

# 반면에 단조 특성을 가지는데 이건 머냐면 a>=b 인 a,b에 대해서 같은 값 c를 더해도 a+c>=b+c 등호가 유지된다.
# 정수의 덧셈에서는 오버플로우 떄문에 단조성이 없지만 부동소수점은 단조성이 있음.

# 부동소숫점의 곱셈
# 곱셈이 닫혀있다 이런얘기가 있는데, 적절한 소수, 무한대, NaN 중에 무조건 하나로 결정된다는 말입니다.
# 교환법칙은 성립하는데 근사값으로 손실되는 값이나, 오버플로우로 인해 결합법칙은 성립하지 않습니다.
# 곱셈도 단조특성이 존재하는데 a>=b일때 c>=0에 대해서 a*c>=b*가 성립하고 c<=0에 대해 a*c<=b*c가 성립합니다.
# 마찬가지로 정수의 곱셈은 단조성이 성립하지 않습니다. 오버플로우 때문에

# 2.4.6 C에서의 부동소수점
# C에선 float와 double을 지원합니다. 그리고 이 머신은 근사할때 짝수 근사모드를 사용합니다.
# 타입간 변환할때 변경점
# 부동소수점 데이터 타입의 표현 가능한 정수 범위, 연속적으로 표현할 수 있는 정수 범위 설명,

# int에서 float으로, 숫자가 오버플로우 되지는 않지만 근사된다.
# int는 -2^31~2^31-1의 수를 나타내는데 float으로 나타낼 수 있는 연속적인 정수는 -2^24~2^24까지 따라서 절댓값이 2^24보다 크면 근사됩니다.

# int나 float에서 double로, 정확한 수치가 보존됨. double은 2^53까지 연속된 정수 표현가능, 또한 지수,가수 필드 모두 float보다 큼
# double에서 float로, 지수와 가수 필드가 모두 작아지기 때문에 값이 오버플로우 하여 갑자기 무한대가 될 수 있다. 혹은 그냥 근사된다.
# float혹은 double에서 int로, 그냥 쉽게 소수점 이후 수를 제거해버린다는 의미 double에서 변환되면 값이 커서 오버플로우도 될 수 있음
# 혹여 수가 너무 크거나 NaN 같은 정수로 표현하기 힘든 수일때 에러 표시값으로 int의 TMin을 반환하는 경우가 있음.
# 그래서 수식 (int)1e10은 TMin을 반환한다.

# 2.5 요약
# 컴퓨터는 정보를 비트로 인코딩하고 이를 연속된 바이트로 구성한다.
# 정수를 표현하기 위해 2의 보수라는 방법을 사용했고 부동소수를 표현하기 위해 IEEE 표준 754를 사용했다.
# 동일한 크기를 갖는 부호형, 비부호형 정수를 캐스팅할때 내부 비트는 변하지 않는다.
# C에서 부호형과 비부호형을 연산하면 비부호형으로 묵시적 타입변환이되어서 종종 버그를 발생하기도 한다.
# 정수의 덧셈과 곱셈은 수를 표현하는 범위가 한정적이어서 오버플로우를 발생할 수 있다.
# 부동소수점도 마찬가지로 표현할 수 있는 범위가 한정적이므로 수를 표현 할 수 없을때 NaN 혹은 무한대로 표시하기도 한다.
# 부동소수점 산술연산은 매우 조심스럽게 사용해야하는데 그 이유는 제한된 범위와 정밀도를 갖기 때문이며, (근사와 오버플로우(무한대))
# 결합법칙이 성립하지 않아 일반적인 수학 법칙을 따르지 않는다.